---
title: "[Chapter 01] 리팩터링: 첫 번째 예시"
description: ""
date: 2024-10-08 14:31:24
update: 2024-10-08 14:31:24
tags:
  - JavaScript
series: 
---

# 공연료 청구서 출력 프로그램

## 🚀 기능 요구사항

- 공연 요청은 연극의 장르와 관객 규모를 기반으로 비용을 책정한다.
    - 장르: 비극(tragedy), 희극(comedy)
- 다음 구매 시 할인 가능한 포인트를 제공한다.

## ✍🏻 입출력

### ⌨️ 입력

1. `invoices.json`: 공연료 청구서
2. `plays.json`: 연극 정보

```json
[
  {
    "customer": "BigCo",
    "performances": [
      {
        "playID": "hamlet",
        "audience": 55
      },
      {
        "playID": "as-like",
        "audience": 35
      },
      {
        "playID": "othello",
        "audience": 40
      }
    ]
  }
]
```

```json
{
  "hamlet": {
    "name": "Hamlet",
    "type": "tragedy"
  },
  "as-like": {
    "name": "As You Like It",
    "type": "comedy"
  },
  "othello": {
    "name": "Othello",
    "type": "tragedy"
  }
}
```

## 1.2 예시 프로그램을 본 소감

> 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.

이미 작동하는 프로그램에 리팩터링을 더해야 하는 이유는 무엇일까? '소프트웨어'는 변화에 유연해야 한다. 하드웨어가 아니다.
애석하게도 변화는 소규모로 문을 두드리지 않는다. 엄청난 규모로 몰려온다. 문을 부술 기세다.

현재 하나의 함수로 구현을 마쳤다. 하지만 요구사항이 추가되면 어떻게 될까? 수정한다. 하나의 함수에 수정을 더함으로 실수를 시작한다.

하지만 역할과 책임에 맞춰 나눠져있다면 어떨까? 관련 부분만 수정한다. 실수할 확률을 낮춘다. 젠가가 떠오른다. 층이 나눠져있다면
빼기 쉽다. 하지만 층이 나눠져있지 않다면 빼기 어렵다. 소프트웨어에서는 어떻게 층을 나눌 수 있을까?

## 1.3 리팩터링의 첫 단계

> 리팩터링 하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가 진단하도록 만든다.

실수하지 않는 사람은 없다. 하지만 실수를 하면 프로그램에 문제가 생기고 치명적인 손실로 다가올 수 있다. 하지만 수정은 해야 한다. 진퇴양난이다.
그렇다면, 선배 개발자는 어떻게 변화에 적응하고 살아남았을까?

'테스트 코드'를 제안한다. 테스트 코드는 사람의 실수를 검증하는 안전장치다. COVID 사태가 떠오른다. 만약 몸 상태를 자동으로 측정하는 프로그램이 있었다면 어땠을까.
언제, 어디서 감염되었는지 즉시 확인할 수 있다면 안정감이 올라가지 않았을까? 테스트 코드는 자가 진단키트와 유사하다.

### 요구사항

- 공연료 청구 출력 결과(청구서)를 비교한다.
- 테스트를 단축키로 등록한다.
